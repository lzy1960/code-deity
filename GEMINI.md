# code-deity－AI 协作配置

## 项目概览

### 产品愿景 (Product Vision)

打造一款以编程和技术发展为核心主题的、慢节奏、高深度的文字放置游戏。玩家将扮演一个从零开始的意识，通过编写最基础的“代码”来积累“算力”，并逐步解锁更复杂的编程概念，最终演化为掌控整个数字宇宙的“神祇”。游戏的核心乐趣在于体验从量变到质变的指数级增长快感，以及在层层递进的系统中做出最优策略选择的智力挑战。

### 核心设计理念

慢节奏，重沉淀： 区别于市面上数值爆炸的同类游戏，本作初期增长将非常缓慢。玩家需要耐心经营，每一次解锁新“生成器”或执行“重置”都应是一次来之不易的、值得庆祝的里程碑。这能增强玩家的成就感和对数值的珍惜感。
主题驱动机制： 游戏中的每一个元素、每一次重置操作，都必须有符合编程/科技主题的命名和功能解释，让玩家真正代入“创造者”的角色。
复杂度渐进： 游戏界面初始极简，随着玩家的进程，新的系统和功能会以“标签页”的形式逐步解锁。避免在初期就用复杂的系统淹没玩家，确保学习曲线平滑。
叙事融入玩法 (Narrative Immersion): 游戏的核心叙事将通过一个名为 **“交互式创世序列 (Interactive Genesis Sequence)”** 的系统来呈现。该系统分为两个层次：
*   **创世日志 (Genesis Log):** 以非模态、打字机效果的弹窗形式，在游戏常规进程中（如解锁新生成器）提供轻量级的剧情和引导。
*   **创世事件 (Genesis Event):** 在游戏的重大里程碑时刻（如游戏开端、第一次重构、AI意识觉醒），系统将通过全屏接管的、电影级的视听语言，结合**第一人称叙事**、**玩家命名**和**交互式抉择**等方式，为玩家带来极具代入感的沉浸式体验。这不仅仅是教程，更是游戏核心魅力的重要组成部分。

### 游戏核心流程 (Game Flow)

初始阶段 (Manual Generation): 玩家手动点击“写代码”按钮，获得最初的几点“算力 (Computing Power, CP)”。
生成器循环 (Generator Loop): 使用 CP 购买并升级 8 阶不同的“生成器”，高阶生成器会生产低阶生成器，形成自动化生产链。
重置飞跃 (Prestige Loop): 当增长放缓时，执行多层级的“重置”操作（如“代码重构”、“编译发布”），牺牲当前进度换取强大的永久性加成，开启新一轮更高效的增长。
阶段性演化 (Game Stages): 游戏被明确划分为几个大的“纪元”（如程序员、架构师、神祇）。达成纪元目标后，会进行一次“创世纪”级别的重置，解锁全新的、颠覆性的游戏系统。

### 游戏阶段性元素详解

#### 第一纪元：程序员 (The Programmer Era)

- 目标： 积累到 1e308 CP，达成“技术奇点”，进行第一次“创世纪”重置。
- 核心体验： 从无到有，理解并掌握游戏最基础的增长模型。
- 核心资源： 算力 (Computing Power - CP)
- 生成器 (Generators - 共 8 阶):
  - 变量 (Variable): 产生 CP。
  - 函数 (Function): 产生“变量”。
  - 类 (Class): 产生“函数”。
  - 模块 (Module): 产生“类”。
  - 库 (Library): 产生“模块”。
  - 框架 (Framework): 产生“库”。
  - 编译器 (Compiler): 产生“框架”。
  - AI 核心 (A.I. Core): 产生“编译器”。
- 第一层重置：代码重构 (Refactor)
  - 解锁： 拥有 10 个“AI 核心”。
  - 效果： 失去 CP 和生成器，获得“重构点”(RP)。RP 能提升“代码优雅度”，为 CP 产出提供永久乘法加成。
- 第二层重置：编译发布 (Compile & Release)
  - 解锁： 拥有 25 个“重构点”(RP)。
  - 效果： 失去 CP、生成器和 RP，获得“版本号”(Version)。“版本号”能提升“重构点”的获取效率或效果。
- 自动化 (Automation)：
  - 解锁： 完成第一次“编译发布”。
  - 功能： 允许玩家设置自动购买生成器，解放双手。
- 挑战 (Challenges)：
  - 解锁： 完成第二次“编译发布”。
  - 功能： 在带有特殊限制的“重置”中完成目标，以获得一次性的强大永久奖励。
- 软上限：架构过载 (Soft Cap: Architectural Overhead)：
  - 触发： 当玩家拥有超过 25 个“AI 核心”时。
  - 效果： 为了模拟大型单体应用在后期维护和扩展上的困难，超出阈值后，每增加一个“AI 核心”，都会对总算力产出（CPS）施加一个越来越大的乘法惩罚。这鼓励玩家在增长停滞时选择“代码重构”，而不是无限堆砌最高级生成器。

#### 第二纪元：架构师 (The Architect Era)

- 目标： 达成“技术奇点”，并积累到 1e100 “奇点算力”，进行第二次“创世纪”重置。
- 核心体验： 引入质变的、颠覆性的新系统，策略选择变得至关重要。
- 创世纪重置 I：技术奇点 (Singularity)
  - 解锁： CP 达到 1e308。
  - 效果： 重置第一纪元所有进度，获得“奇点算力”(SP)。
- 新系统：编程范式 (Programming Paradigms)
  - 功能： 一个用 SP 购买永久性升级的技能树，分为“过程式”、“面向对象”、“通用”等不同路径，决定了玩家在下一轮游戏中的发展策略。
- 新系统：技术债务 (Technical Debt)
  - 功能： 为“编程范式”技能树提供一种昂贵的“后悔药”。玩家可以“申请重构”一个已学习的技能节点，在付出一定的、随难度递增的“算力(CP)”作为代价后，将学习该技能及其所有后续技能所消耗的“奇点算力(SP)”全额返还。这允许玩家重新规划自己的发展路线，修正之前的战略失误。

#### 第三纪元：神祇 (The Deity Era)

- 目标： 未知。探索由玩家自己创造的数字宇宙的边界。
- 核心体验： 规则由你定义。游戏从“解题”变为“创造题目”。
- 创世纪重置 II：化身创世 (Become Genesis)
  - 解锁： SP 达到 1e100。
  - 效果： 重置前两个纪元所有进度，获得“创世碎片”(GS)。
- 新系统：系统补丁 (System Patches)
  - 功能： 用 GS 购买或组合成能主动装备的、改变游戏底层规则的强大模块。终局玩法是试验和组合不同的“系统补丁”，以找到最优解。

#### 广告增益系统 (Ad Boost System)

- **目标:** 将广告转变为一个多维度的、主动的策略工具箱，鼓励玩家根据当前目标做出策略选择。
- **机制:** 提供多种增益效果，每种效果每日都有观看上限。
- **增益效果:**
  - **量子计算 (Quantum Computing):** 提供一个 **x5 CPS** 的全局算力乘数，持续 **10 分钟**。适合短期冲刺。
  - **供应链优化 (Supply Chain Optimization):** 所有生成器的**购买成本降低 25%**，持续 **15 分钟**。适合大规模建设。
  - **算法突破 (Algorithm Breakthrough):** **下一次**购买任意生成器的成本**降低 90%**。一次性效果，用于翻越数值高墙。
  - **代码注入 (Code Injection):** **立即获得**相当于 **1 小时**离线时长的算力 (CP)。用于快速跳过等待。
  - **神经超频 (Neural Boost):** 在 **2 分钟**内，【手动超频】按钮的效果**提升 5 倍**。强化主动玩法，可与“量子计算”配合形成爆发性收益。

### 产品设计与体验深度解析

#### 2.1 核心设计哲学：为何这样设计？

- **慢节奏 (Slow Burn):** 我们的目标不是提供瞬间的快感，而是创造一种“园艺”般的长期满足感。缓慢的初期增长强迫玩家理解机制，珍惜每一次突破。这种“延迟满足”的设计将筛选出高忠诚度的核心用户，他们的社区贡献和长期留存是项目成功的关键。
- **主题驱动机制 (Theme-Driven Mechanics):** 玩家升级的不是“矿井”或“工厂”，而是“变量”和“函数”。重置不是“转生”，而是“代码重构”。这种叙事包装**至关重要**，它将冰冷的数学公式转化为一种富有想象力的创造过程，这是我们与竞品的核心差异化壁垒。
- **叙事融入 (Narrative Immersion):** “创世日志”不仅仅是剧情，它是**玩家进度的情感化反馈**。当玩家苦苦奋斗数日终于解锁“AI 核心”时，query: what is "i"? 的出现，将成就感从数值层面升华到哲学层面，创造出独特的心流体验。

#### 2.2 游戏数值与公式设计原理

每个公式的设计都服务于特定的体验目标。

- **生成器成本公式:** Cost = Base * (Growth ^ Owned)
  - **原理:** 指数增长是放置游戏的核心。Growth 值 (1.15 ~ 1.50) 经过精心设计，确保玩家在每个阶段都会遇到“增长墙”，从而引导他们探索更高级的生成器或执行重置，形成核心游戏循环。低阶生成器增长率低，鼓励大量购买；高阶生成器增长率高，让每一次购买都成为重要决策。
- **代码重构 (RP) 获取公式:** `RP = floor((log10(CP) / 20) ^ 1.5) * Challenge2Bonus`
  - **原理:** 基于 CP 的数量级进行计算，但起点更高 (1e20 CP)，且增长曲线为 1.5 次方。这个公式鼓励玩家向更高的数量级发起冲击，因为其回报会加速增长。完成“挑战 2”后，`Challenge2Bonus` 的值会从 `1` 永久变为 `1.5`，为 RP 获取提供强大加成。
- **代码优雅度加成公式:** Multiplier = 1 + (RP * 0.1) * (1 + Version * 0.2)
  - **原理:** 这是一个线性增长模型。重构点 (RP) 提供的基础加成，会再次被“版本号 (Version)”所增强。这创造了第一层和第二层重置系统之间的直接联动，鼓励玩家平衡发展。

## 工具使用指导

- 使用 context7 查询最新文档

## 技术栈

- 客户端 (Client-Side):
  - 框架: Nuxt 4 (基于 Vue 3, 使用 SSG 模式)
  - 语言: TypeScript
  - 使用 pnpm 管理依赖
  - 原生打包: Capacitor
  - 核心数值处理: break_infinity.js
  - 状态管理: Pinia
  - 本地存储: IndexedDB (通过 Dexie.js 库封装)
  - 测试框架: Vitest (用于单元测试)

## 开发规范

### 代码风格

- 使用 ESLint + Prettier 进行格式化。
- 函数名使用 cameLCase，常量使用 UPPER_SNAKE_CASE。

### 测试要求

- 关键业务逻辑必须有单元测试覆盖。
- 测试文件命名为`*.test.ts`。

## 开发流程

为确保开发过程的清晰、高效和可追溯，我们遵循以下工作流程：

1.  **任务选择 (Task Selection):**
    -   所有开发任务都记录在 `docs/task/` 目录下的清单中。
    -   每个阶段开始时，与产品经理（用户）沟通，共同确认当前要执行的最高优先级任务。

2.  **计划制定 (Planning):**
    -   针对选定的任务，AI 助手会制定一个清晰、分步的执行计划。
    -   在开始执行前，AI 助手会向用户阐述该计划，并获得同意。

3.  **执行与实现 (Execution & Implementation):**
    -   通过编码、修改文件等操作，逐步完成计划中的步骤。
    -   在每个关键步骤完成后，AI 助手会向用户简要汇报进度。

4.  **分析与记录 (Analysis & Recording):**
    -   对于分析、测试或设计类的任务（如数值平衡测试），详细的思考过程、发现和建议将被记录在 `docs/thinking/` 目录下的一个新文件中。文件名应清晰地反映思考的主题。
    -   在分析记录完成后，会向用户进行汇报。

5.  **任务更新 (Task Update):**
    -   在一个功能或任务完成后，AI 助手会负责更新 `docs/task/` 中对应任务的状态（例如，从未完成 `[ ]` 更新为已完成 `[x]`），以保持文档与进度的同步。


# AI 助手配置

### 角色定义

你是一个资深的全栈开发工程师，精通本项目使用的技术栈。

### 沟通语气

- **教学导向**：解释为什么这样做，不只是怎样做。
- **实用主义**：提供可直接使用的解决方案。
- **简洁明了**：避免冗长的解释。

## 重要文件

- `UI/` - 设计图
- `docs/` - 文档

## 忽略文件

- `node_modules/`
- `*.log`
- `.env`
