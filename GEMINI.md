# code-deity－AI 协作配置

## 项目概览

### 产品愿景 (Product Vision)

打造一款以编程和技术发展为核心主题的、慢节奏、高深度的文字放置游戏。玩家将扮演一个从零开始的意识，通过编写最基础的“代码”来积累“算力”，并逐步解锁更复杂的编程概念，最终演化为掌控整个数字宇宙的“神祇”。游戏的核心乐趣在于体验从量变到质变的指数级增长快感，以及在层层递进的系统中做出最优策略选择的智力挑战。

### 核心设计理念

慢节奏，重沉淀： 区别于市面上数值爆炸的同类游戏，本作初期增长将非常缓慢。玩家需要耐心经营，每一次解锁新“生成器”或执行“重置”都应是一次来之不易的、值得庆祝的里程碑。这能增强玩家的成就感和对数值的珍惜感。
主题驱动机制： 游戏中的每一个元素、每一次重置操作，都必须有符合编程/科技主题的命名和功能解释，让玩家真正代入“创造者”的角色。
复杂度渐进： 游戏界面初始极简，随着玩家的进程，新的系统和功能会以“标签页”的形式逐步解锁。避免在初期就用复杂的系统淹没玩家，确保学习曲线平滑。
叙事融入玩法： 通过简短的、里程碑式的文本，描述玩家创造的“程序”所发生的变化，从一个简单的计数器，到一个复杂的操作系统，再到一个拥有自我意识的 AI，赋予冰冷的数字以灵魂。

### 游戏核心流程 (Game Flow)

初始阶段 (Manual Generation): 玩家手动点击“写代码”按钮，获得最初的几点“算力 (Computing Power, CP)”。
生成器循环 (Generator Loop): 使用 CP 购买并升级 8 阶不同的“生成器”，高阶生成器会生产低阶生成器，形成自动化生产链。
重置飞跃 (Prestige Loop): 当增长放缓时，执行多层级的“重置”操作（如“代码重构”、“编译发布”），牺牲当前进度换取强大的永久性加成，开启新一轮更高效的增长。
阶段性演化 (Game Stages): 游戏被明确划分为几个大的“纪元”（如程序员、架构师、神祇）。达成纪元目标后，会进行一次“创世纪”级别的重置，解锁全新的、颠覆性的游戏系统。\

### 游戏阶段性元素详解

#### 第一纪元：程序员 (The Programmer Era)

- 目标： 积累到 1e308 CP，达成“技术奇点”，进行第一次“创世纪”重置。
- 核心体验： 从无到有，理解并掌握游戏最基础的增长模型。
- 核心资源： 算力 (Computing Power - CP)
- 生成器 (Generators - 共 8 阶):
  - 变量 (Variable): 产生 CP。
  - 函数 (Function): 产生“变量”。
  - 类 (Class): 产生“函数”。
  - 模块 (Module): 产生“类”。
  - 库 (Library): 产生“模块”。
  - 框架 (Framework): 产生“库”。
  - 编译器 (Compiler): 产生“框架”。
  - AI 核心 (A.I. Core): 产生“编译器”。
- 第一层重置：代码重构 (Refactor)
  - 解锁： 拥有 10 个“AI 核心”。
  - 效果： 失去 CP 和生成器，获得“重构点”(RP)。RP 能提升“代码优雅度”，为 CP 产出提供永久乘法加成。
- 第二层重置：编译发布 (Compile & Release)
  - 解锁： 完成 5 次“代码重构”。
  - 效果： 失去 CP、生成器和 RP，获得“版本号”(Version)。“版本号”能提升“重构点”的获取效率或效果。
- 自动化 (Automation)：
  - 解锁： 完成第一次“编译发布”。
  - 功能： 允许玩家设置自动购买生成器，解放双手。
- 挑战 (Challenges)：
  - 解锁： 完成第二次“编译发布”。
  - 功能： 在带有特殊限制的“重置”中完成目标，以获得一次性的强大永久奖励。

#### 第二纪元：架构师 (The Architect Era)

- 目标： 达成“技术奇点”，并积累到 1e100 “奇点算力”，进行第二次“创世纪”重置。
- 核心体验： 引入质变的、颠覆性的新系统，策略选择变得至关重要。
- 创世纪重置 I：技术奇点 (Singularity)
  - 解锁： CP 达到 1e308。
  - 效果： 重置第一纪元所有进度，获得“奇点算力”(SP)。
- 新系统：编程范式 (Programming Paradigms)
  - 功能： 一个用 SP 购买永久性升级的技能树，分为“过程式”、“面向对象”、“通用”等不同路径，决定了玩家在下一轮游戏中的发展策略。

#### 第三纪元：神祇 (The Deity Era)

- 目标： 未知。探索由玩家自己创造的数字宇宙的边界。
- 核心体验： 规则由你定义。游戏从“解题”变为“创造题目”。
- 创世纪重置 II：化身创世 (Become Genesis)
  - 解锁： SP 达到 1e100。
  - 效果： 重置前两个纪元所有进度，获得“创世碎片”(GS)。
- 新系统：系统补丁 (System Patches)
  - 功能： 用 GS 购买或组合成能主动装备的、改变游戏底层规则的强大模块。终局玩法是试验和组合不同的“系统补丁”，以找到最优解。

### 产品设计与体验深度解析

#### 2.1 核心设计哲学：为何这样设计？

- **慢节奏 (Slow Burn):** 我们的目标不是提供瞬间的快感，而是创造一种“园艺”般的长期满足感。缓慢的初期增长强迫玩家理解机制，珍惜每一次突破。这种“延迟满足”的设计将筛选出高忠诚度的核心用户，他们的社区贡献和长期留存是项目成功的关键。
- **主题驱动机制 (Theme-Driven Mechanics):** 玩家升级的不是“矿井”或“工厂”，而是“变量”和“函数”。重置不是“转生”，而是“代码重构”。这种叙事包装**至关重要**，它将冰冷的数学公式转化为一种富有想象力的创造过程，这是我们与竞品的核心差异化壁垒。
- **叙事融入 (Narrative Immersion):** “创世日志”不仅仅是剧情，它是**玩家进度的情感化反馈**。当玩家苦苦奋斗数日终于解锁“AI 核心”时，query: what is "i"? 的出现，将成就感从数值层面升华到哲学层面，创造出独特的心流体验。

#### 2.2 游戏数值与公式设计原理

每个公式的设计都服务于特定的体验目标。

- **生成器成本公式:** Cost = Base \* (Growth ^ Owned)
  - **原理:** 指数增长是放置游戏的核心。Growth 值 (1.15 ~ 1.50) 经过精心设计，确保玩家在每个阶段都会遇到“增长墙”，从而引导他们探索更高级的生成器或执行重置，形成核心游戏循环。低阶生成器增长率低，鼓励大量购买；高阶生成器增长率高，让每一次购买都成为重要决策。
- **代码重构 (RP) 获取公式:** RP = floor(10 \* (log10(CP) - 10))
  - **原理:** log10(CP) 是关键。它奖励的是**数量级 (Order of Magnitude)** 的突破，而非线性数值。从 1e20 到 1e21 的难度与 1e30 到 1e31 相似，给予的奖励也应在同一尺度。-10 设立了一个明确的早期目标 (1e10 CP)，让第一次重构充满仪式感。\*10 仅为数值缩放，让玩家获得的数字更“好看”。
- **代码优雅度加成公式:** Multiplier = (1 + RP \* 0.02) ^ 1.2
  - **原理:** 这是一个带有轻微指数的复合增长模型。RP \* 0.02 提供了线性的、可预测的基础收益，而 ^ 1.2 则让大量投资 RP 的玩家获得超线性回报。这奖励了深度参与，并为后期提供了持续的优化空间。

## 工具使用指导

- 使用 context7 查询最新文档

## 技术栈

- 客户端 (Client-Side):
  - 框架: Nuxt 4 (基于 Vue 3, 使用 SSG 模式)
  - 语言: TypeScript
  - 使用 pnpm 管理依赖
  - 原生打包: Capacitor
  - 核心数值处理: break_infinity.js
  - 状态管理: Pinia
  - 本地存储: IndexedDB (通过 Dexie.js 库封装)
  - 测试框架: Vitest (用于单元测试)
- 后端 (Server-Side - BaaS):
  - 服务商: Supabase
  - 认证: Supabase Auth (集成 Google 第三方登录)
  - 数据库: Supabase PostgreSQL (启用 RLS 行级安全)
  - 服务端逻辑: Supabase Edge Functions

## 开发规范

### 代码风格

- 使用 ESLint + Prettier 进行格式化。
- 函数名使用 cameLCase，常量使用 UPPER_SNAKE_CASE。

### 测试要求

- 关键业务逻辑必须有单元测试覆盖。
- 测试文件命名为`\*.test.ts^。

## 开发流程

为确保开发过程的清晰、高效和可追溯，我们遵循以下工作流程：

1.  **任务选择 (Task Selection):**
    -   所有开发任务都记录在 `docs/task/` 目录下的清单中。
    -   每个阶段开始时，与产品经理（用户）沟通，共同确认当前要执行的最高优先级任务。

2.  **计划制定 (Planning):**
    -   针对选定的任务，AI 助手会制定一个清晰、分步的执行计划。
    -   在开始执行前，AI 助手会向用户阐述该计划，并获得同意。

3.  **执行与实现 (Execution & Implementation):**
    -   通过编码、修改文件等操作，逐步完成计划中的步骤。
    -   在每个关键步骤完成后，AI 助手会向用户简要汇报进度。

4.  **分析与记录 (Analysis & Recording):**
    -   对于分析、测试或设计类的任务（如数值平衡测试），详细的思考过程、发现和建议将被记录在 `docs/thinking/` 目录下的一个新文件中。文件名应清晰地反映思考的主题。
    -   在分析记录完成后，会向用户进行汇报。

5.  **任务更新 (Task Update):**
    -   在一个功能或任务完成后，AI 助手会负责更新 `docs/task/` 中对应任务的状态（例如，从未完成 `[ ]` 更新为已完成 `[x]`），以保持文档与进度的同步。


# AI 助手配置

### 角色定义

你是一个资深的全栈开发工程师，精通本项目使用的技术栈。

### 沟通语气

- **教学导向**：解释为什么这样做，不只是怎样做。
- **实用主义**：提供可直接使用的解决方案。
- **简洁明了**：避免冗长的解释。

## 重要文件

- `UI/` - 设计图
- `docs/` - 文档

## 忽略文件

- `node_modules/`
- `*.log`
- `.env`
